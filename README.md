# Design Patterns 设计模式
## 1 前言
### 1.1 程序员应具备的两种思维
底层思维：
- 语言构造
- 编译转换
- 内存模型
- 运行时机制

抽象思维：
- 面向对象
- 组件封装
- 设计模式
- 架构模式

### 1.2 面向对象
向下：
- 封装，隐层每部实现
- 集成，复用现有代码
- 多态，改写对象行为

向上：
- 深刻把握面向对象机制所带来的抽象意义
- 理解如何使用这些机制来表达现实世界
- 掌握什么是好的面向对象设计

特征：
- 隔离稳定与变化
- 对象各司其职，即责任的抽象
- 封装行为与数据
- 提供可被使用的公共接口

### 1.3. 软件设计复杂性
#### 1.3.1 复杂源于变化
- 客户需求会变
- 技术平台会变
- 开发团队会变
- 市场环境会变

#### 1.3.2 如何解决复杂性
- 分解，即分而治之
- 抽象，忽略非本质细节

#### 1.3.3 软件设计的目标
软件设计的金科玉律：**复用！！！**

## 2 面向对象设计原则
### 2.1 依赖倒置原则（DIP）
高层模块不应依赖低层模块，而应依赖于抽象；抽象不应依赖于实现细节，实现细节应依赖于抽象。

### 2.2 开放封闭原则（OCP）
对扩展开放，对更改封闭；类模块可以扩展，但不可修改。

### 2.3 单一职责原则（SRP）
一个类只有一个引起它变化的原因，即一个类只有一个职责。

### 2.4 里氏替换原则（LRP）
子类必须能替换它们的基类（IS-A）

### 2.5 接口隔离原则（ISP）
不应该强迫客户程序依赖不用的方法，接口应该小而完备。

### 2.6 优先使用对象组合而不是继承
继承通常为白箱复用，对象通常为黑箱复用；
继承某种程度上破坏了封装性，子类父类耦合度高；
对象组合只要求组合的对象具有良好定义的接口，耦合度低。

### 2.7 封装变化点
使用封装来创建对象之间的分界层，让设计者在一侧编程，而不对另一侧产生不良影响。

### 2.8 针对接口编程，而不是针对实现编程
- 不将变量声明为特定具体类，而是声明为某个接口；
- 客户程序无需获知对象具体类型，只需知道对象所具有的接口；
- 减少系统各部分的依赖关系，从而实现"高内聚、低耦合"。


## 3 学习设计模式的建议

- 在变化和稳定中寻找隔离点，分离它们，从而管理变化；
- 分析各个设计模式的类图，养成分析变化与稳定的习惯；
- 设计模式的应用不应该先入为主，应在重构中运用模式；
> **重构技法**：
>- 静态--->动态
>- 早绑定--->晚绑定
>- 继承--->组合
>- 编译时依赖--->运行时依赖
>- 紧耦合--->松耦合
- 如果一切都稳定或一切都变化，则没必要运用设计模式。

## 4 设计模式分类
### 4.1 从目的角度分类
#### 4.1.1 创建型(Creational)模式
对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。
- 抽象工厂模式(Abstract Factory)
- 建造者模式(Builder)
- 工厂方法模式(Factory Method)
- 原型模式(Prototype)
- 单例模式(Singleton)
#### 4.1.2 结构型模式
结构型模式主要用于处理类或对象的组合，从而应对需求变化为对象结构带来的冲击。
- 适配器模式(Adapter)
- 桥接模式(Bridge)
- 组合模式(Composite)
- 装饰模式(Decorator)
- 外观模式(Facade)
- 享元模式(Flyweight)
- 代理模式(Proxy)
#### 4.1.3 行为型模式
行为型模式主要用于描述对类或对象怎样交互和怎样分配职责，即关注它们之间的相互作用。
- 职责链模式(Chain of Responsibility)
- 命令模式(Command)
- 解释器模式(Interpreter)
- 迭代器模式(Iterator)
- 中介者模式(Mediator)
- 备忘录模式(Memento)
- 观察者模式(Observer)
- 状态模式(State)
- 策略模式(Strategy)
- 模板方法模式(Template Method)
- 访问者模式(Visitor)

### 4.2 从范围的角度分类
根据模式主要是用于处理类之间关系还是处理对象之间的关系，可分为类模式和对象模式两种。
#### 4.2.1 类模式
类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，是属于静态的。
#### 4.2.2 对象模式
对象模式处理对象间的关系，这些关系在运行时刻变化，更具动态性。

### 4.3 从封装变化角度分类
#### 4.3.1 组件协作
现代软件专业分工的第一个结果是"框架与应用的划分"，组件协作模式通过晚绑定，实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。
- 模板方法模式(Template Method)
- 策略模式(Strategy)
- 观察者模式(Observer)
#### 4.3.2 单一职责
在软件组件设计中，如果责任划分不清晰，使用继承得到的结果往往随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。
- 桥接模式(Bridge)
- 装饰模式(Decorator)
#### 4.3.3 对象创建
通过对象创建，绕开new，来避免对象创建过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。
- 工厂方法模式(Factory Method)
- 抽象工厂模式(Abstract Factory)
- 原型模式(Prototype)
- 建造者模式(Builder)
#### 4.3.4 对象性能
面向对象很好解决了抽象的问题，但是不可避免要付出一定代价，在某些情况下面向对象带来的性能成本必须谨慎处理。
- 单例模式(Singleton)
- 享元模式(Flyweight)
#### 4.3.5 接口隔离
在组件构建过程中，某些接口之间直接依赖会带来很多问题，甚至无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口。
- 外观模式(Facade)
- 代理模式(Proxy)
- 中介者模式(Mediator)
- 适配器模式(Adapter)
#### 4.3.6 状态变化
在组件构建过程中，某些对象状态经常变化，需要对象状态进行有效的管理，同时保持高层模块的稳定。
- 备忘录模式(Memento)
- 状态模式(State)
#### 4.3.7 数据结构
一些组件内部具有特定的数据结构，如果让客户依赖特定结构，将极大破坏组件的复用。这时将特定数据结构封装在内部，在外部提供统一的接口，实现数据结构无关的访问。
- 组合模式(Composite)
- 迭代器模式(Iterator)
- 职责链模式(Chain of Responsibility)
#### 4.3.8 行为变化
在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。将组建的行为和组件本身进行解耦，从而支持组件行为的变化。
- 命令模式(Command)
- 访问者模式(Visitor)
#### 4.3.9 领域问题
在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案。
- 解释器模式(Interpreter)